#!/usr/bin/python
#from gurobipy import *
import math, argparse, time
import aco as aco
import random
import multiprocessing
#import matplotlib.pyplot as plt
import math
import sys
import collections
from ortools.sat.python import cp_model
import copy
import support as sp
import constructiveHeuristics as conheu
import tabu as tabu


# Display solution information

class HCSolutionPrinter(cp_model.CpSolverSolutionCallback):
    """Print intermediate solutions."""

    def __init__(self, d, x, y, sols):
        cp_model.CpSolverSolutionCallback.__init__(self)
        self._vertices = d.vertices
        self._colours = d.colours
        self._mat = d.mat
        self._x = x
        self._y = y
        self._solutions = set(sols)
        self._solution_count = 0

    def on_solution_callback(self):
        if self._solution_count in self._solutions:
            print('Solution %i' % self._solution_count)
            for d in range(self._vertices):
                print(' Vertex %i has colour %i' % (d, self.Value(self._x[d])))
            print()
        self._solution_count += 1

    def solution_count(self):
        return self._solution_count

# callback for CP solver (not using much)
class VarArraySolutionPrinterWithLimit(cp_model.CpSolverSolutionCallback):
    """Print intermediate solutions."""
    def __init__(self, d, x, limit):
        cp_model.CpSolverSolutionCallback.__init__(self)
        self.__x = x
        self.__solution_count = 0
        self.__limit = limit
        self.__search_info = None
        self.__obj_traces = []

    def on_solution_callback(self):
        self.__solution_count += 1
        self.__obj_traces.append(self.Value(self.__x[0]))
        if self.__solution_count >= self.__limit:
            self.StopSearch()
            self.__search_info = [self.__obj_traces, self.NumBranches()]
        obj_val = d.vertices - self.ObjectiveValue()
        print("\t\tIntermediate objective:" + str(obj_val))
            
    def get_info(self):
        return {'objective': self.__obj_traces, 'search': self.__search_info}
    
# Build the CP model
def build_model(d, rtime, fixed, ss):
    model = cp_model.CpModel()
    # Define variables
    # x_i = colour of vertex i
    x = {}
    # y_i = 1 if vertex i is unhappy
    y = {}
    b = {}

    for i in range(d.vertices):
        x[i] = model.NewIntVar(lb=0, ub=d.colours-1, name = 'v_'+str(i))
        y[i] = model.NewBoolVar(name = 'v_'+str(i))
        b[i] = model.NewBoolVar(name = 'b_'+str(i))
    
    # Define constraints

    # Assign precolours
    # Fix any variable if they are specified in fixed
    # Set a starting solution
    
    for i in range(d.vertices):
        if d.cv[i] != -1:
            model.Add(x[i] == d.cv[i])

        # Rule out any colours that should not appear
        for j in range(d.colours):
            if fixed[i, j] == 1:    
                model.Add(x[i] != j)

        # fix colours that should always appear
        #for j in range(d.colours):
        #    if fixed[i, j] != -1:    
        #        model.Add(x[i] == fixed[i, j])

    #if ss[0] != -1:
    #    print("\tSetting a starting solution ...")
    #    for i in range(d.vertices):
    #        model.AddHint(x[i],ss[i])
    
    # Link between x and y
    for i in range(d.vertices):
        for j in range(d.vertices):
            if (d.mat[i][j] != 1) or (i == j): continue
            # b[i] == (x[i] != x[j])
            model.Add(x[i] != x[j]).OnlyEnforceIf(b[i])
            model.Add(x[i] == x[j]).OnlyEnforceIf(y[i].Not())
            # b[i] => (y[i] == 1)
            model.Add(y[i] == 1).OnlyEnforceIf(b[i])
            model.Add(y[i] <= 1).OnlyEnforceIf(b[i].Not())
    
    # Define the objective functiozn
    # Minimize the number of unhappy vertices
    obj_var = model.NewIntVar(0, d.vertices, 'unhappy')
    for i in range(d.vertices):
        obj_var += y[i]
    model.Minimize(obj_var)

    # DSolve and display a few solutions
    solver = cp_model.CpSolver()
    solver.parameters.max_time_in_seconds = rtime
    solver.parameters.enumerate_all_solutions = True
    solver.parameters.log_search_progress = True
    solver.parameters.num_search_workers = 1
    solver.log_callback = print
    a_few_sols = 10000
    solution_printer = VarArraySolutionPrinterWithLimit(d, [obj_var], a_few_sols)
    #status = solver.SolveWithSolutionCallback(model, solution_printer)
    status = solver.Solve(model)#SolveWithSolutionCallback(model, solution_printer)

    if status != cp_model.OPTIMAL and status != cp_model.FEASIBLE:
        print("Problem solving CP model -> likely infeasible.")
        exit()
    obj_val = d.vertices - solver.ObjectiveValue()
    if status == cp_model.OPTIMAL:
        print("\tSolved, and found an optimal solution!")
    else:
        print("\tSolved, and found a feasible solution!")
    print("\t"+ "Sat solver objective = " + str(obj_val))
    # Print solution.
    #if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:
    #    print()
    #    for i in range(vertices):
    #        print("Vertex " + str(i) + " assigned colour " + str(solver.Value(x[i]))
    #              + " and unhappy " + str(solver.Value(y[i])))
    #    print(f'Total cost = {solver.ObjectiveValue()}')

    #else:
    #    print('No solution found.')

    #print()
    #print('Statistics')
    #print('  - conflicts       : %i' % solver.NumConflicts())
    #print('  - branches        : %i' % solver.NumBranches())
    #print('  - wall time       : %f s' % solver.WallTime())
    #print('  - solutions found : %i' % solution_printer.solution_count())

    #Extract the solution
    happyV = []
    cols = []
    for i in range(d.vertices):
        happyV.append(0)
        cols.append(solver.Value(x[i]))
        happy = 1
        for j in range(d.vertices):
            if (d.mat[i][j] != 1) or (i == j): continue
            if solver.Value(x[i]) != solver.Value(x[j]):
                happy = 0
                break
        if happy == 1:
            happyV[i] = 1
    items = []
    sol = sp.Sol(cols, happyV, d.vertices - solver.ObjectiveValue(), items)
    
    return sol

    
# Solve the happy colouring problem with the first model
def solve_CP(d, rtime):
    print("Solving a constraint programming model of the Happy Colourings problem ...")
    fixed = []
    ss = []
    for i in range(d.vertices):
        fixed.append(-1)
        ss.append(-1)

    obj = build_model(d, rtime, fixed, ss)

# Solve the happy colouring problem CMSA (CP solver)
def solve_CMSA(d, rtime, stime):
    print("Solving the Happy Colourings problem with CMSA and CP ...")
    verbosity = 0
    isols = 3 # This should really be a parameter
    max_age = 2
    start_time = time.time()
    (fixed, sols, age) = sp.initialiseData(d, isols-1)

    # First, determine an aditional set of precoloured vertices
    #conheu.addPrecolourings(d, verbosity)
    b_sol = conheu.makeInitSol(d)

    # conduct a tabu search
    tabuParameter = 4.0
    biggerNeighbourhood = 0
    display = 1
    tabu_time = rtime/10
    tabu_time = 1
    R = tabu.tabuSearch(d, b_sol, tabu_time, tabuParameter, biggerNeighbourhood, display);
    sols.append(b_sol)
    x_start = []
    for i in range(d.vertices):
        x_start.append(b_sol.col[i])
    
    itr = 1
    bsol_change = 0
    while time.time() - start_time < rtime:
        probs = sp.changeCols(d, sols, b_sol, isols, age, itr)
        #Keep track of start variables 
        fixed_vars = {}
        # Ensure the last solution has the data for b_sol
        for i in range(d.vertices):
            for j in range(d.colours):
                fixed_vars[i,j] = 1 # Initially no colours for any vertex is allowed
                #fixed_vars[i,j] = -1 # Initially all colours for any vertex is allowed
                
        # Set the starting solution to the best one
        if bsol_change == 1: # Otherwise x_start already has the best solution
            print("\tBest solution changed ...")
            sols[isols-1] = copy.deepcopy(b_sol)
            for i in range(d.vertices):
                x_start[i] = b_sol.col[i]
                

        # Decide which colours to rule out for every variable
        for s in range(isols):
            for i in range(d.vertices):
                # Rule out variables
                colour = sols[s].col[i]
                fixed_vars[i, colour] = 0
                age[i, colour] += 1
               
        #for i in range(d.vertices):
        #    if d.cv[i] != -1: continue
        #    same = 1
        #    val = sols[0].col[i]
        #    for s in range(1,isols):
        #        if sols[s].col[i] != val:
        #            same = 0
        #            break;
        #    if same == 1:
        #        fixed_vars[i] = val;
        #        print("Fixed " + str(i) + " to " + str(val))

        # Additionally, if the age of a variable, colour pair is 0, rule it out 
        for i in range(d.vertices):
            for j in range(d.colours):
                if age[i, j] == 0: fixed_vars[i, j] = 1
        #        else: fixed_vars[i, j] = 0 
                
        print("Solving restricted CP model: " + str(itr))
        # Solve restricted CP model
        t = time.time()
        sol = build_model(d, stime, fixed_vars, x_start)
        print("\tTime: " + str(time.time() - t))
        bsol_change = 0
        if sol.numHappy > b_sol.numHappy: 
            b_sol = copy.deepcopy(sol)
            bsol_change = 1
            print("\t**** Improvement found " + str(sol.numHappy) + ", " + str(b_sol.numHappy))
        # Reset the age if the limit is reached
        for i in range(d.vertices):
            for j in range(d.colours):
                if sol.col[i] == j:
                    age[i,j] = 1
                if age[i,j] >= max_age:
                    age[i,j] = 0;

        print("\tBest solution: " + str(b_sol.numHappy))
        itr+=1
        #print("\tTime: " + str(time.time() - start_time))

    end_time = time.time()
    print('Total time taken\t',time.time()-start_time)

# The main file starts here
ap = argparse.ArgumentParser()
ap.add_argument('--input', type=str,
    help='''The input file from which the problem data will be extracted.''')
ap.add_argument('--model', type=str,
    help='''Which model to use when optimising.''')
ap.add_argument('--meth', default='CMSA', type=str,
                help='''What method to use, MIP, ACO or CMSA?''')
ap.add_argument('--rtime', default=600, type=str,
    help='''Total run time?''')
ap.add_argument('--stime', default=10, type=str,
    help='''Solver time?''')


args = ap.parse_args()
fileName = args.input
model = args.model
method = args.meth
rtime = float(args.rtime)
stime = float(args.stime)

#start_time=time.clock()
#(vertices,colours,mat,cv)=read_file(fileName)
d=sp.read_DIMACS(fileName)
if method == "aco":
    aco.ExeACO(d.vertices, d.colours, d.mat, d.cv, start_time, rtime)
# Solve a CP model of the HC problem
elif method == "cp":
    solve_CP(d, rtime)
#solve CMSA
else:
    solve_CMSA(d, rtime, stime)
    
#print('Total time taken\t',time.clock()-start_time)
