import networkx as nx
import numpy as np
import random, copy
#from dimacs import *

def genSBM(n, k, p, q, s,pre_coloured_pc): #n=number of vertices, k=number of partitions, p=edge probabilities inside communities, q=intercommunity edge probabilities, s=probability seed
    sizes=np.zeros(k,dtype=int)
    c=np.zeros((k,pre_coloured_pc),dtype=int) #pre-colored vertices
    comm=[]
    for i in range(k):
        comm.append([])
        sizes[i]=int(n/k)
        comm[i].append(range(i*int(n/k), (i+1)*int(n/k)))
        #c[i]=random.randint(i*int(n/k), (i+1)*int(n/k))

    if (int(n/k)!=n/k):
        for t in range(k*int(n/k),n):
            comm[t%k].append(t)
            sizes[t%k]+=1

    p1=np.ones((k,k))
    p1=q*p1
    p2=np.identity(k)
    p2=(p-q)*p2
    probs=p1+p2
    probs=probs.tolist()
    G=nx.stochastic_block_model(sizes, probs,seed=s)
    U=copy.deepcopy(set(G.nodes))
    for u in G.nodes:
        G.nodes[u]["c"]=-1


    V=[]
    for i in range(k):
        A=[]
        V.append(A)
        for j in range(pre_coloured_pc):
            c[i][j]=random.choice(list(set(range(i*int(n/k), (i+1)*int(n/k))).intersection(U)))
            G.nodes[c[i][j]]["c"]=i
            V[i].append(c[i][j])
            U.remove(c[i][j])

    comment1="c algorithm:genSBM, n="+str(n)+' k='+str(k)+" p="+str(p)+" q="+str(q)+" seed="+str(s)+" number of precoloured vertices per community ="+str(pre_coloured_pc)+"\n"
    comment2="c parameters= "+str(n)+' '+str(k)+" "+str(p)+" "+str(q)+" "+str(s)+" "+str(pre_coloured_pc)+"\n"

    return G,V,U,comment1, comment2#G=the graph, V=[V_1,...,V_k] colour classes, U=uncoloured vertices
   # filename="SBM_n="+str(n)+"_k="+str(k)+"_p="+str(round(p,2))+"_q="+str(round(q,3))+"_seed="+str(s)+".txt"

  #  dimacs(G, c, k, filename)
def write_dimacs(G, V, file_name, comment1, comment2):
    k=len(V)
    with open(file_name, "w") as f:
        # write the header
        f.write("c This is a graph generated by the stochastic block model, using the command networkx.stochastic_block_model(sizes, probs,seed=s) in Python, written in DIMACS format. Some or all verties are coloured so that the graph can be used for (soft) happy colouring problems. The colouring might have been completed or altered via the following algorithm (if different from ((genSBM))). \n")
        f.write(comment1)
        f.write(comment2)

        f.write("p EDGE {} {} {}\n".format(G.number_of_nodes(), G.number_of_edges(), k))
        # now write all edges
        for u, v in G.edges():
            f.write("e {} {}\n".format(u, v))
        for i in range(k):
            for u in V[i]:
                f.write("n {} {}\n".format(u, i))

def read_dimacs(filename):
    k=1
    G=nx.Graph()
    with open(filename, "r") as f:
        n = -1
        m = -1
        m_cnt = 0
        for i,l in enumerate(f.readlines()):
            if l[0]=='c':
                if l[2]!='p':
                    continue
                else:
                    j = i
                    _,fmt,nn,kstr2,p,q,s,pcc=l.split()
                    if fmt!='parameters=':
                        raise ValueError("Syntax error: "+ "line {} contains a wrong format: parametres= is expected.".format(i))
            if l[0]=='p':
                if n>=0:
                    raise ValueError("Syntax error: "+ "line {} contains a second spec line.".format(i))
                _,fmt,nstr,mstr,kstr = l.split()
                if fmt!='EDGE':
                     raise ValueError("Input error: "+ "Dimacs \'edge\' format expected.".format(i))
                n = int(nstr)
                n2 = int(nn)
                if n!=n2:
                    raise ValueError("Syntax error: "+ "line {} contradics the line {}.".format(i, j))
                m = int(mstr)
                G.add_nodes_from(range(n))
                for i in range(n):
                    G.nodes[i]["c"]=-1
                continue
            if l[0]=='e':
                m_cnt +=1
                _,v,w=l.split()
                G.add_edge(int(v),int(w))

            if l[0]=='n':
                _,v,w=l.split()
                G.nodes[int(v)]["c"]=int(w)
                if int(w)>=k:
                    k=int(w)+1

    if m!=m_cnt:
        raise ValueError("Syntax error: "+"{} edges were expected.".format(m))
    if k!=int(kstr):
        raise ValueError("Syntax error: "+"{} colours were expected.".format(k))

    U=copy.deepcopy(set(G.nodes))
    V=[]
    for i in range(k):
        A=[]
        V.append(A)

    for v in G.nodes:
        if G.nodes[v]["c"]!=-1:
            V[G.nodes[v]["c"]].append(v)
            U.remove(v)

    parameters=[n,k,p,q,s,pcc]

    return G,V,U,parameters


